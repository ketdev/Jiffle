# value abstractions
foo = 3

# evaluation abstractions (functions)
[a] add [b] {
	a + b
}

# symbol (invoked)
foo

# reference (not invoked)
&foo

2 add 2 # 4


# ( 'hi' )
# 3 * (3 + 3)
# 
# 2 + 2 // 4
# 3 + (1 + 2) // 6; can nest, 
# // order of operation is always from left to right, 
# // invoking functions when encountered
#  
# // data sequences, can mix types
# ( 1,2,3,'hi' )
# 
# // strings are sequences of characters
# ( 'h','i' ) // string
# ( "hello ","world" ) // sequence of strings != string
# // to get functions as literals, escape their evaluation
# ( 3,\+,1 ) // 3,+,1 sequence
#  
# // functions
# [a] add [b] = a + b
# 3 add 8 // 11

